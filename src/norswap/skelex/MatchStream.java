package norswap.skelex;

import java.util.Comparator;
import java.util.HashMap;
import java.util.Map;
import java.util.Set;
import java.util.function.Function;
import java.util.stream.Collectors;
import java.util.stream.Stream;

/**
 * A match stream represents a set of regex matches generated by a {@link Runner}.
 * <p>
 * Instances of this class are acquired through {@link Runner#matches}, or through the
 * {@link #concat(MatchStream...)} method. If the instance comes directly from a {@link Runner},
 * then all the matches match up to the same fixed input position.
 * <p>
 * The methods of this class are used to filter and extract matches of interest. Just like
 * Java's {@link Stream} class, each operation is either intermediate or terminal.
 * <p>
 * Unlike Java's {@link Stream}, all operations can be called on the same object:
 * intermediate operations mutate the stream then return it. However, only a single terminal
 * operation can be called, after which further operations will throw an
 * {@link IllegalStateException}.
 */
public final class MatchStream
{
    // ---------------------------------------------------------------------------------------------

    /**
     * Concatenates multiple match streams into a single one. All streams must have been obtained
     * from the same {@link Runner} (or through concatenation of streams obtained therefrom).
     */
    public static MatchStream concat (MatchStream... streams)
    {
        if (streams.length == 0)
            return new MatchStream(Stream.empty(), null);

        Runner runner = streams[0].runner;

        Stream<Checkpoint> checkpoints = Stream.of(streams)
            .map(it -> {
                if (it.runner != runner)
                    throw new IllegalArgumentException(
                        "Passed match streams were generated by different runners.");
                return it.stream;
            })
            .flatMap(Function.identity());

        return new MatchStream(checkpoints, runner);
    }

    // ---------------------------------------------------------------------------------------------

    Stream<Checkpoint> stream;

    // ---------------------------------------------------------------------------------------------

    /**
     * The runner that emitted this match stream.
     */
    public final Runner runner;

    // ---------------------------------------------------------------------------------------------

    MatchStream (Stream<Checkpoint> stream, Runner runner)
    {
        this.stream = stream;
        this.runner = runner;
    }

    // ---------------------------------------------------------------------------------------------

    /**
     * Filters the matches to only preserve those for the given registration.<p>
     * This is an intermediate operation and returns this stream.
     */
    public MatchStream for_registration (Regex regex, int start)
    {
        stream = stream.filter(it -> it.regex == regex && it.start == start);
        return this;
    }

    // ---------------------------------------------------------------------------------------------

    /**
     * Filters the matches to only preserve those for {@code regex}.<p>
     * This is an intermediate operation and returns this stream.
     */
    public MatchStream for_regex (Regex regex)
    {
        stream = stream.filter(it -> it.regex == regex);
        return this;
    }

    // ---------------------------------------------------------------------------------------------

    /**
     * Filters the matches to only preserve those starting at position {@code start}.<p>
     * This is an intermediate operation and returns this stream.
     */
    public MatchStream for_starting_pos (int start)
    {
        stream = stream.filter(it -> it.start == start);
        return this;
    }


    // ---------------------------------------------------------------------------------------------

    /**
     * Filters the matches to only preserve those ending at position {@code end}.<p>
     * This is an intermediate operation and returns this stream.
     */
    public MatchStream ending_at (int end)
    {
        stream = stream.filter(it -> it.pos == end);
        return this;
    }

    // ---------------------------------------------------------------------------------------------

    /**
     * Filters the matches to only preserve those starting at position {@code start} and ending at
     * position {@code end}.<p>
     * This is an intermediate operation and returns this stream.
     */
    public MatchStream for_range (int start, int end)
    {
        stream = stream.filter(it -> it.start == start && it.pos == end);
        return this;
    }

    // ---------------------------------------------------------------------------------------------

    /**
     * Filters the matches to only preserve those for {@code regex} starting at position {@code
     * start} and ending at position {@code end}.<p>
     * This is an intermediate operation and returns this stream.
     */
    public MatchStream for_range (int start, int end, Regex regex)
    {
        stream = stream.filter(it -> it.regex == regex && it.start == start && it.pos == end);
        return this;
    }

    // ---------------------------------------------------------------------------------------------

    private Checkpoint longest_checkpoint() {
        return stream.max(Comparator.comparingInt(it -> it.pos - it.start)).orElse(null);
    }

    // ---------------------------------------------------------------------------------------------

    private Match checkpoint_to_match (Checkpoint cp) {
        return cp == null ? null : new Match(cp.regex, cp.start, cp.pos);
    }

    // ---------------------------------------------------------------------------------------------

    private MatchTree checkpoint_to_tree (Checkpoint cp) {
        return cp == null ? null : runner.tree(cp, cp.pos);
    }

    // ---------------------------------------------------------------------------------------------

    /**
     * Returns the longest match in the stream. If there are multiple such matches, the method
     * selects the match corresponding to the chronologically earliest registration.<p>
     * This is a final operation.
     */
    public Match longest() {
        return checkpoint_to_match(longest_checkpoint());
    }

    // ---------------------------------------------------------------------------------------------

    /**
     * Returns the tree match for the longest match in the stream. If there are multiple such
     * matches, the method selects the match corresponding to the chronologically earliest
     * registration.
     * <p>
     * This is a final operation.
     * <p>
     * The tree is selected by prioritizing the presence of an item over its absence, choice
     * alternatives in the order they appear, and earlier sub-regexes over later ones. See <a
     * href="https://github.com/norswap/skelex/blob/master/doc/README.md">the user manual</a> for
     * more details.
     */
    public MatchTree longest_tree() {
        return checkpoint_to_tree(longest_checkpoint());
    }

    // ---------------------------------------------------------------------------------------------

    /**
     * Returns a map from regexes to the longest match for that regex.<p>
     * This is a final operation.
     */
    public Map<Regex, Match> longest_per_regex()
    {
        // NOTE(norswap)
        // We're not using Stream#toMap because disambiguation forces creating two Match objects
        // instead of one.

        HashMap<Regex, Match> map = new HashMap<>();

        stream.forEach(cp ->
            map.compute(cp.regex,
                (k, v) -> v == null || cp.pos - cp.start > v.end - v.start
                    ? checkpoint_to_match(cp)
                    : v));

        return map;
    }

    // ---------------------------------------------------------------------------------------------

    /**
     * Returns a map from regexes to the longest tree match for that regex.
     * <p>
     * This is a final operation.
     * <p>
     * The trees are selected by prioritizing the presence of an item over its absence, choice
     * alternatives in the order they appear, and earlier sub-regexes over later ones. See <a
     * href="https://github.com/norswap/skelex/blob/master/doc/README.md">the user manual</a> for
     * more details.
     */
    public Map<Regex, MatchTree> longest_tree_per_regex()
    {
        // NOTE(norswap)
        // We're not using Stream#toMap because disambiguation forces creating two MatchTree objects
        // instead of one (expensive!).

        HashMap<Regex, MatchTree> map = new HashMap<>();

        stream.forEach(cp ->
            map.compute(cp.regex,
                (k, v) -> v == null || cp.pos - cp.start > v.end - v.start
                    ? checkpoint_to_tree(cp)
                    : v));

        return map;
    }

    // ---------------------------------------------------------------------------------------------

    /**
     * Returns all matches in the stream. This is guaranteed not to include duplicate matches (hence
     * there is only a single match per registration).<p>
     * This is a final operation.
     */
    public Set<Match> get()
    {
        return stream
            .map(this::checkpoint_to_match)
            .collect(Collectors.toSet());
    }

    // ---------------------------------------------------------------------------------------------

    /**
     * Returnes match trees for all matches in the stream. This is guarantee to only include
     * a single tree per registration.
     * <p>
     * This is a final operation.
     * <p>
     * The trees are selected by prioritizing the presence of an item over its absence, choice
     * alternatives in the order they appear, and earlier sub-regexes over later ones. See <a
     * href="https://github.com/norswap/skelex/blob/master/doc/README.md">the user manual</a> for
     * more details.
     */
    public Set<MatchTree> trees()
    {
        return stream
            .map(this::checkpoint_to_tree)
            .collect(Collectors.toSet());
    }

    // ---------------------------------------------------------------------------------------------

    /**
     * Returns the set of regexes for which there is a match in the stream.<p>
     * This is a final operation.
     */
    public Set<Regex> regexes()
    {
        return stream
            .map(it -> it.regex)
            .collect(Collectors.toSet());
    }

    // ---------------------------------------------------------------------------------------------

    /**
     * Indicates whether there is at least one match left in the stream.<p>
     * This is a final operation.
     */
    public boolean matching() {
        return stream.findFirst().isPresent();
    }

    // ---------------------------------------------------------------------------------------------
}
