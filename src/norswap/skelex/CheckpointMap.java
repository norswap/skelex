package norswap.skelex;

import norswap.utils.Pair;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.LinkedHashMap;

/**
 * Maps input positions to sets of checkpoints reachable at those positions based on the input
 * seen by a {@link Runner} so far. Each runner maintains a unique checkpoint map.
 */
final class CheckpointMap
{
    // ---------------------------------------------------------------------------------------------

    private final ArrayList<LinkedHashMap<Checkpoint, Checkpoint>> checkpoints = new ArrayList<>();

    // ---------------------------------------------------------------------------------------------

    /**
     * Returns all checkpoints at the {@code index} position, returning an empty list
     * if no checkpoints are recorded for the given position.
     */
    Collection<Checkpoint> get (int index)
    {
        if (index >= checkpoints.size())
            return Collections.emptySet();

        LinkedHashMap<Checkpoint, Checkpoint> map = checkpoints.get(index);
        return map != null ? map.values() : Collections.emptySet();
    }

    // ---------------------------------------------------------------------------------------------

    /**
     * Returns true if there are no checkpoints at the given index.
     */
    boolean is_empty (int index)
    {
        if (index >= checkpoints.size())
            return true;

        LinkedHashMap<Checkpoint, Checkpoint> map = checkpoints.get(index);
        return map == null || map.isEmpty();
    }

    // ---------------------------------------------------------------------------------------------

    /**
     * Merge a checkpoint at the {@code index} position, creating the underlying data structures
     * as needed.
     *
     * @param index a position {@code >=} the current position
     */
    void add (int index, Checkpoint checkpoint)
    {
        while (index >= checkpoints.size())
            checkpoints.add(null);

        if (checkpoints.get(index) == null)
            checkpoints.set(index, new LinkedHashMap<>());

        LinkedHashMap<Checkpoint, Checkpoint> map = checkpoints.get(index);
        if (map == null)
            checkpoints.set(index, map = new LinkedHashMap<>());

        Checkpoint canonical = map.get(checkpoint);

        if (canonical == null)
            map.put(checkpoint, checkpoint);
        else
            // by construction: only a single transition, which will be different from the others
            canonical.merge_transitions(checkpoint);
    }

    // ---------------------------------------------------------------------------------------------

    /**
     * Removes the checkpoints generated by the last {@code amount} items of input, given that
     * we currently are at input position {@code pos}.
     */
    void clear_last (int pos, int amount)
    {
        int size = checkpoints.size();
        if (pos - amount >= size) return;
        int end = Math.min(size, pos + 1);

        for (int i = pos + 1 - amount; i < end; ++i)
            checkpoints.set(i, null);
    }

    // ---------------------------------------------------------------------------------------------
}
