package norswap.skelex;

import norswap.utils.Util;
import java.util.Collections;
import java.util.List;

import static norswap.skelex.DSL.*;
import static norswap.skelex.MatchTree.$;
import static norswap.utils.Util.cast;
import static norswap.utils.Vanilla.concat;

/**
 * Enables the construction of advanced regexes via static methods.
 * <p>
 * Unlike the regexes created via {@link DSL}, these DSL are not "primitive": they don't compile
 * to their own state machine, and are instead assembled from primitive regexes.
 * <p>
 * Because of this, the resulting match trees will be sub-optimal. For instance the regex {@code
 * twomore(x)}, when matching 4 instances of whatever {@code x} matches, will generate the match
 * node {@code [x, [x, x, x]]} because the regex is constructed as {@code seq(x, onemore(x))}.
 * Obviously, {@code [x, x, x, x]} would be a more desirable match node.
 * <p>
 * To alleviate this issue, this class includes methods with the same name as the regexes whose role
 * is to extract better-looking trees from the tree or match nodes generated by the regex.
 */
public final class DSL2
{
    // =============================================================================================
    // COMBINATORS

    // ---------------------------------------------------------------------------------------------

    /**
     * Returns a regex matching a sequence of 0 or more matches for {@code item} separated by
     * matches for {@code sep}.
     *
     * <p>Equivalent regex: {@code maybe(item, zeromore(sep, item))}
     */
    public static Regex separated0 (Regex item, Regex sep) {
        return maybe(item, zeromore(sep, item));
    }

    // ---------------------------------------------------------------------------------------------

    /**
     * Returns a regex matching a sequence of 1 or more matches for {@code item} separated by
     * matches for {@code sep}.
     *
     * <p>Equivalent regex: {@code seq(item, zeromore(sep, item))}
     */
    public static Regex separated1 (Regex item, Regex sep) {
        return seq(item, zeromore(sep, item));
    }

    // ---------------------------------------------------------------------------------------------

    /**
     * Returns a regex matching a sequence of 1 or more matches for {@code item} separated by
     * matches for {@code sep}.
     *
     * <p>Equivalent regex: {@code seq(item, onemore(sep, item))}
     */
    public static Regex separated2 (Regex item, Regex sep) {
        return seq(item, onemore(sep, item));
    }

    // ---------------------------------------------------------------------------------------------

    /**
     * Returns a regex matching a sequence of 2 or more matches for {@code item}.
     *
     * <p>Equivalent regex: {@code seq(item, onemore(item))}
     */
    public static Regex twomore (Regex item) {
        return seq(item, onemore(item));
    }

    // =============================================================================================
    // EXTRACTORS

    // ---------------------------------------------------------------------------------------------

    /**
     * If fed a match tree generated by {@link #separated0(Regex, Regex)}, will return a list of
     * match nodes corresponding to the separated items (separators are omitted), casted to
     * the required type {@link T}.
     */
    public static <T> List<T> separated0 (MatchTree tree) {
        return separated0(Util.<List<T>>cast(tree.value()));
    }

    // ---------------------------------------------------------------------------------------------

    /**
     * If fed a match node generated by {@link #separated0(Regex, Regex)}, will return a list of
     * match nodes corresponding to the separated items (separators are omitted), casted to the
     * required type {@link T}.
     */
    public static <T> List<T> separated0 (List<?> list) {
            return separated1(list);
    }

    // ---------------------------------------------------------------------------------------------

    /**
     * If fed a match tree generated by {@link #separated1(Regex, Regex)}, will return a list of
     * match nodes corresponding to the separated items (separators are omitted).
     */
    public static <T> List<T> separated1 (MatchTree tree) {
        return separated1(Util.<List<T>>cast(tree.value()));
    }

    // ---------------------------------------------------------------------------------------------

    /**
     * If fed a match node generated by {@link #separated1(Regex, Regex)}, will return a list of
     * match nodes corresponding to the separated items (separators are omitted), casted to the
     * required type {@link T}.
     *
     * <p>If {@code list} is null (which shouldn't occur under normal conditions), returns an
     * empty list.
     */
    public static <T> List<T> separated1 (List<?> list)
    {
        if (list == null) return Collections.emptyList();
        Object first = list.get(0);
        List<Object> rest = MatchTree._fmap(list, 1, $, 1);
        return cast(concat(first, rest));
    }

    // ---------------------------------------------------------------------------------------------

    /**
     * If fed a match tree generated by {@link #separated2(Regex, Regex)}, will return a list of
     * match nodes corresponding to the separated items (separators are omitted), casted to the
     * required type {@link T}.
     */
    public static <T> List<T> separated2 (MatchTree tree) {
        return separated1(Util.<List<T>>cast(tree.value()));
    }

    // ---------------------------------------------------------------------------------------------

    /**
     * If fed a match node generated by {@link #separated2(Regex, Regex)}, will return a list of
     * match nodes corresponding to the separated items (separators are omitted), casted to the
     * required type {@link T}.
     *
     * <p>If {@code list} is null (which shouldn't occur under normal conditions), returns an
     * empty list.
     */
    public static <T> List<T> separated2 (List<?> list) {
        return separated1(list);
    }

    // ---------------------------------------------------------------------------------------------

    /**
     * If fed a match tree generated by {@link #twomore(Regex)}, will return a list of match nodes
     * corresponding to the matched items, casted to the required type {@link T}.
     */
    public static <T> List<T> twomore (MatchTree tree) {
        return twomore(Util.<List<T>>cast(tree.value()));
    }

    // ---------------------------------------------------------------------------------------------

    /**
     * If fed a match node generated by {@link #twomore(Regex)}, will return a list of match nodes
     * corresponding to the matched items, casted to the required type {@link T}.
     *
     * <p>If {@code list} is null (which shouldn't occur under normal conditions), returns an
     * empty list.
     */
    public static <T> List<T> twomore (List<?> list)
    {
        return list == null
            ? Collections.emptyList()
            : cast(concat(list.get(0), list.get(1)));
    }

    // ---------------------------------------------------------------------------------------------
}
